<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      const data = { foo: 'hello world', bar: '111' };
      let temp1, temp2;
      let activeEffect;

      const activeEffectStack = [];

      const bucket = new WeakMap(); // 副作用函数的桶 使用WeakMap

      function effect(fn) {
        const funEffect = function () {
          cleanEffect(funEffect);
          activeEffect = funEffect; // 这里每次都是最新的 如果嵌套了 就会导致 嵌套的 fn 执行完后  没有恢复 所以这里要保存之前的funEffect
          activeEffectStack.push(activeEffect);
          fn();
          // 执行完之后 恢复 activeEffect
          // 先把它从 activeEffectStack 移除掉 执行完的 funEffect
          activeEffectStack.pop();
          activeEffect = activeEffectStack[activeEffectStack.length - 1];
        };
        funEffect.deps = [];
        funEffect(); // 执行副作用函数
      }

      function cleanEffect(funEffect) {
        if (!funEffect.deps) return;
        funEffect.deps.forEach((dep) => {
          dep.delete(funEffect);
        });
        // 最后需要重置 effectFn.deps 数组
        funEffect.deps.length = 0;
      }

      const obj = new Proxy(data, {
        get(target, p, receiver) {
          track(target, p);
          return Reflect.get(...arguments);
        },
        set(target, p, value, receiver) {
          Reflect.set(...arguments); // 设置属性值
          trigger(target, p); // 把副作用函数取出并执行
          return Reflect.set(...arguments);
        },
      });

      // track函数
      function track(target, key) {
        if (!activeEffect) return target[key]; // 没有正在执行的副作用函数 直接返回
        let depsMap = bucket.get(target);
        if (!depsMap) {
          // 不存在，则创建一个Map
          bucket.set(target, (depsMap = new Map()));
        }
        let deps = depsMap.get(key); // 根据key得到 depsSet(set类型), 里面存放了该 target-->key 对应的副作用函数
        if (!deps) {
          // 不存在，则创建一个Set
          depsMap.set(key, (deps = new Set()));
        }
        activeEffect.deps.push(deps); // 将当前的副作用函数deps添加到 deps 集合中

        deps.add(activeEffect); // 将副作用函数加进去
      }

      // trigger函数
      function trigger(target, key) {
        const depsMap = bucket.get(target); // target Map
        if (!depsMap) return true;
        const deps = depsMap.get(key); // effectFn Set

        // deps && deps.forEach((fn) => fn()); // 这里不能这样写  虽然 cleanEffect 清除了
        //  但因为 执行fn的时候 又会重新收集依赖   deps.add(activeEffect); // 将副作用函数加进去 又会重新 add进去  deps 会一直删 一直加 就会无限循环的执行fn

        const newDeps = new Set(deps); // 创建一个 新的 Set

        newDeps && newDeps.forEach((fn) => fn()); // 要这么写 循环和 新增 deps 操作的是两个 set []

        return true; // 返回true
      }

      effect(() => {
        console.log(1, 'log');
        effect(() => {
          console.log(2, 'log');
          temp2 = obj.bar;
        });
        temp1 = obj.foo;
      });
      obj.foo = 222;
    </script>
  </body>
</html>
