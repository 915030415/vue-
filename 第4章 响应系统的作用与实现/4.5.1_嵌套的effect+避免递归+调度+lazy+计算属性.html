<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      const data = { foo: 1, bar: 2 };
      let temp1, temp2;
      let activeEffect;

      const activeEffectStack = []; // 副作用函数的栈
      const bucket = new WeakMap(); // 副作用函数的桶 使用WeakMap
      const jobQueue = new Set(); // 任务队列 自动会去重 副作用函数
      let isFlushing = false; // 是否正在刷新队列
      let p = Promise.resolve(); // 用来创建一个微任务队列把 副作用 函数放在微任务队列里面去
      function flushJob() {
        if (isFlushing) return;
        isFlushing = true;
        p.then(() => {
          jobQueue.forEach((job) => job());
        }).finally(() => {
          isFlushing = false;
        });
      }

      function effect(fn, options = {}) {
        const funEffect = function () {
          cleanEffect(funEffect);
          activeEffect = funEffect; // 这里每次都是最新的 如果嵌套了 就会导致 嵌套的 fn 执行完后  没有恢复 所以这里要保存之前的funEffect
          activeEffectStack.push(activeEffect);
          const res = fn();
          // 执行完之后 恢复 activeEffect
          // 先把它从 activeEffectStack 移除掉 执行完的 funEffect
          activeEffectStack.pop();
          activeEffect = activeEffectStack[activeEffectStack.length - 1];
          return res;
        };
        funEffect.options = options;
        funEffect.deps = [];
        if (!options.lazy) {
          funEffect(); // 执行副作用函数
        }
        return funEffect;
      }

      function cleanEffect(funEffect) {
        if (!funEffect.deps) return;
        funEffect.deps.forEach((dep) => {
          dep.delete(funEffect);
        });
        // 最后需要重置 effectFn.deps 数组
        funEffect.deps.length = 0;
      }

      const obj = new Proxy(data, {
        get(target, p, receiver) {
          track(target, p);
          return Reflect.get(...arguments);
        },
        set(target, p, value, receiver) {
          Reflect.set(...arguments); // 设置属性值
          trigger(target, p); // 把副作用函数取出并执行
          return Reflect.set(...arguments);
        },
      });

      // track函数
      function track(target, key) {
        if (!activeEffect) return target[key]; // 没有正在执行的副作用函数 直接返回
        let depsMap = bucket.get(target);
        if (!depsMap) {
          // 不存在，则创建一个Map
          bucket.set(target, (depsMap = new Map()));
        }
        let deps = depsMap.get(key); // 根据key得到 depsSet(set类型), 里面存放了该 target-->key 对应的副作用函数
        if (!deps) {
          // 不存在，则创建一个Set
          depsMap.set(key, (deps = new Set()));
        }
        activeEffect.deps.push(deps); // 将当前的副作用函数deps添加到 deps 集合中

        deps.add(activeEffect); // 将副作用函数加进去
      }

      // trigger函数
      function trigger(target, key) {
        const depsMap = bucket.get(target); // target Map
        if (!depsMap) return true;
        const deps = depsMap.get(key); // effectFn Set

        // deps && deps.forEach((fn) => fn()); // 这里不能这样写  虽然 cleanEffect 清除了
        //  但因为 执行fn的时候 又会重新收集依赖   deps.add(activeEffect); // 将副作用函数加进去 又会重新 add进去  deps 会一直删 一直加 就会无限循环的执行fn

        const newDeps = new Set(deps); // 创建一个 新的 Set

        newDeps &&
          newDeps.forEach((fn) => {
            if (fn.options.scheduler) {
              fn.options.scheduler(fn);
            } else if (fn !== activeEffect) {
              // 避免无效递归 因为可能 读取和设置 是同一个副作用函数
              fn();
            }
          }); // 要这么写 循环和 新增 deps 操作的是两个 set []

        return true; // 返回true
      }

      function computed(getter) {
        let value;
        let dirty = true;
        const effectFn = effect(getter, {
          lazy: true,
          scheduler(fn) {
            // 这里不用执行fn  effectFn 就是 fn 返回出去了让 用户获取的时候再去执行
            dirty = true;
            trigger(obj, 'value'); // 当 getter 酣睡里面的 数据 被改变了 会触发执行 这个scheduler 函数 然后我们 trigger 触发 去执行   track(obj, 'value'); 收集的 当 computed 取值的时候 把当前的副作用函数
          },
        });

        const obj = {
          get value() {
            if (dirty) {
              value = effectFn();
              dirty = false;
            }
            if (activeEffect) {
              // 当 computed 取值的时候 把当前的副作用函数 收集到 全局的桶中
              track(obj, 'value');
            }
            return value;
          },
        };
        return obj;
      }

      // effect(() => {
      //   console.log(1, 'log');
      //   effect(() => {
      //     console.log(2, 'log');
      //     temp2 = obj.bar;
      //   });
      //   temp1 = obj.foo;
      //   obj.foo++;
      // });
      // obj.foo = 222;

      // effect(
      //   () => {
      //     console.log(obj.foo);
      //   },
      //   {
      //     scheduler(fn) {
      //       jobQueue.add(fn);
      //       flushJob();
      //     },
      //     lazy: true,
      //   }
      // );

      // obj.foo++;
      // obj.foo++;

      // console.log('结束了');

      // const computedData = computed(() => obj.foo + obj.bar);

      // effect(() => {
      //   console.log(computedData.value);
      // });

      // obj.foo++;

      function traverse(value, seen = new Set()) {
        // 这里的作用就是递归的去读取 value 里面的所有属性 让Effect 收集到每个属性 然后 修改value的时候都可以触发 cb
        // seen 防止 循环引用的
        if (!value || typeof value !== 'object' || seen.has(value)) return; // 先不考虑数组的情况
        seen.add(value);
        for (const k in value) {
          traverse(value[k], seen);
        }
        return value;
      }

      // source 可以是 getter 可以是一个 响应式对象
      function watch(source, cb) {
        let getter;
        let newValue, oldValue;
        if (typeof source === 'function') {
          getter = source;
        } else {
          getter = () => traverse(source);
        }
        const effectFn = effect(getter, {
          lazy: true,
          scheduler(fn) {
            newValue = effectFn();
            console.log(fn === effectFn, 'asdfasf'); // true
            cb(oldValue, newValue);
            oldValue = newValue;
          },
        });
        oldValue = effectFn();
      }

      // watch(obj, (oldValue, newValue) => {
      //   console.log(oldValue, 'log', newValue, oldValue === newValue); // true
      // });
      // obj.bar++;

      watch(
        () => obj.bar,
        (oldValue, newValue) => {
          console.log(oldValue, 'log', newValue, oldValue === newValue); // 2 3 false
        }
      );
      obj.bar++;
    </script>
  </body>
</html>
